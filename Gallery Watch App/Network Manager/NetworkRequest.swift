//
//  NetworkRequest.swift
//  Gallery Watch App
//
//  Created by Mac-OBS-18 on 25/01/23.
//

import Foundation

public enum URLType {
    case directURL
    case formedURL
}

/// A structure denoting a HTTP header field
public struct HTTPHeaderField: Hashable, CustomReflectable {
    /// Global constant for the `Accept` field
    public static let accept = HTTPHeaderField("Accept")

    /// Global constant for the `Content-Length` field
    public static let contentLength = HTTPHeaderField("Content-Length")

    /// Global constant for the `Content-Type` field
    public static let contentType = HTTPHeaderField("Content-Type")

    /// The field's name
    public let fieldName: String

    public private(set) var hashValue: Int

    /// Designated initalizer to create a header field
    ///
    /// - Parameter stringValue: The field's name
    public init(_ stringValue: String) {
        fieldName = stringValue

        hashValue = fieldName.lowercased().hashValue
    }

    public func hash(into hasher: inout Hasher) {
        fieldName.lowercased().hash(into: &hasher)
    }

    public var customMirror: Mirror { // custom override so that we don't manage the hashValue
        let children: [Mirror.Child] = [(label: "fieldName", value: fieldName)]

        return Mirror(self,
                      children: children,
                      displayStyle: .struct)
    }
}

/// An enumeration of possible errors generated by requests
///
/// - openStream: This error denotes that the given InputStream object was opened
/// - queryItemsInPath: This error denotes that the given path contains query items,
/// i.e. contains `?` and/or `=`. Please use `NetworkRequest.queryItems`
/// - unableToFormURL: The NetworkObject was unable to construct the final URL object from the given arguments
public enum RequestError: Error {
    /// This error denotes that the given InputStream object was opened
    case openStream

    /// This error denotes that the given path contains query items, i.e. contains `?` and/or `=`.
    /// Please use `NetworkRequest.queryItems`
    case queryItemsInPath

    /// The NetworkObject was unable to construct the final URL object from the given arguments
    /// We're probably going to deprecate this in a near-future
    case unableToFormURL
}

/// Protocol that denotes an item that can be either expressed directly as a `NetworkRequest` or can be derived into one
public protocol NetworkRequestable: Equatable, CustomReflectable {

}

public enum HTTPMethod: String, Equatable {
    /// the GET method
    case get = "GET"

    ///  the POST method
    case post = "POST"

    /// the HEAD method
    case head = "HEAD"

    /// the PUT method
    case put = "PUT"

    /// the DELETE method
    case delete = "DELETE"

    /// the CONNECT method
    case connect = "CONNECT"

    /// the OPTIONS method
    case options = "OPTIONS"

    /// the TRACE method
    case trace = "TRACE"

    /// the PATCH method
    case patch = "PATCH"
}

/// A generic class that is the baseline representation of a network request.
open class NetworkRequest: NetworkRequestable {

    public var parameter: Parameter?

    public var pathType: URLType?

    public var parameterData: Data?

    public var mode: EncodeType?

    /// The authorization requirement for the requeskt
    ///
    /// - never: Never add authorization annotations for this request
    /// - optional: Add authorization annotations for this request if available
    /// - required: Authorization annotations are required for this request
    public enum AuthorizationRequirement {
        /// Never add authorization annotations for this request
        case never

        /// Add authorization annotations for this request if available
        /// If a `RequestAuthenticator` is available, everything will
        /// proceed like an authenticated request,
        /// except errors will be gracefully handled
        case optional

        /// Authorization annotations are required for this request
        case required
    }

    /// The HTTP Method to use for this request
    public let HTTPMethod: HTTPMethod

    /// If an authentication method is required for the request to succeed. See `Authenticator`
    @available(*, deprecated,
    message: "Please query `NetworkRequest.authorizationRequirement`",
    renamed: "authorizationRequirement")
    public var isAuthenticationRequred: Bool {
        return authorizationRequirement == .required
    }

    /// The authorization requirement of this request
    public let authorizationRequirement: AuthorizationRequirement

    /// If the request should request additional execution time when entering the background.
    ///
    /// Warning: Use *wisely*.
    public let shouldExtendBackgroundExecution: Bool

    /// A dictionary of HTTP headers for the request
    open var HTTPHeaders: [HTTPHeaderField: String] = [:]

    /// The request's path
    ///
    /// - See Also:
    ///  `queryItems`
    open var path: String = "/"

    /// An array of query items to append path
    open var queryItems: [URLQueryItem] = []

    /// An optional pagination request descriptor
    /// An optional `InputStream` representing the requests's HTTP body (if applicable with the method).
    ///
    /// - See Also:
    ///  `validateRequest()`
    open var inputStream: InputStream?

    /// A structure denoting a key to be used in the user info
//    public struct UserInfoKey: RawRepresentable, Equatable, Hashable {
//        public typealias RawValue = String
//
//        public init?(rawValue: String) {
//            self.rawValue = rawValue
//        }
//
//        public var rawValue: String
//    }

    /// A dictionary containing user info about the request
//    open var userInfo: [UserInfoKey: Any] = [:]

    /// The content type to be set as the value for the `Content-Type` header field
    open var contentType: String? = nil {
        didSet {
            updateContentType()
        }
    }

    /// The encoding of the data being sent
    ///
    /// - Discussion: This value will be appended to the `Content-Type` header field
    ///
    /// - Important: This value will be appended if, and only if `contentType` is non-nil
    open var encoding: String.Encoding? = nil {
        didSet {
            updateContentType()
        }
    }

    /// Deprecated Desiginated initializer
    ///
    ///   - method: The request's HTTPMethod
    ///   - authenticatedRequest: If the request is authenticated
    ///   - shouldExtendBackgroundExecution: If we should extend the background execution for this method
    @available(*, deprecated, renamed: "init(_:authorizationRequirement:shouldExtendBackgroundExecution:)")
    public init(_ method: HTTPMethod, authenticatedRequest: Bool = false, shouldExtendBackgroundExecution: Bool = false) {
        let authorizationRequirement: AuthorizationRequirement

        if authenticatedRequest {
            authorizationRequirement = .required
        } else {
            authorizationRequirement = .never
        }

        HTTPMethod = method

        self.authorizationRequirement = authorizationRequirement

        self.shouldExtendBackgroundExecution = shouldExtendBackgroundExecution
    }

    public init(_ method: HTTPMethod, authorizationRequirement: AuthorizationRequirement) {
        HTTPMethod = method

        self.authorizationRequirement = authorizationRequirement

        self.shouldExtendBackgroundExecution = false
    }

    deinit {
        cleanup()
    }

    /// Method that validates the receiver
    ///
    /// - Throws: An error if the request isn't valid
    open func validateRequest() throws {
        if let inputStream = inputStream {
            guard inputStream.streamStatus == .notOpen else {
                throw RequestError.openStream
            }
        }

        if let lastPathComponent = path.components(separatedBy: "/").last {
            if lastPathComponent.contains("?") || lastPathComponent.contains("=") {
                throw RequestError.queryItemsInPath
            }
        }
    }

    /// Method that constructs an URLRequest object based on our self
    ///
    /// - Parameters:
    ///   - baseURL: The base URL to resolve against
    ///   - additionalURLQueryItems: An array of `URLQueryItem`s to append to construct the URL
    /// - Returns: An URLRequest object
    /// - Throws: An error if the request isn't valid, of if we're unable to form the URL
    open func constructURLRequest(baseURL: URL, additionalURLQueryItems: [URLQueryItem]) throws -> URLRequest {
        updateContentType()

        try validateRequest()

        let url = constructURL(baseURL: baseURL, additionalURLQueryItems: additionalURLQueryItems)

        var request = URLRequest(url: url)

        request.allHTTPHeaderFields = HTTPHeaders.reduce(into: [String: String]()) { $0[$1.key.fieldName] = $1.value }

        request.httpMethod = HTTPMethod.rawValue

        request.httpBodyStream = inputStream

        return request
    }

    /// Helper method to construct an URL based on a baseURL
    ///
    /// - Parameters:
    ///   - baseURL: The base URL to resolve against
    ///   - additionalURLQueryItems: An array of `URLQueryItem`s to append to construct the URL
    /// - Returns: The constructed URL
    open func constructURL(baseURL: URL, additionalURLQueryItems: [URLQueryItem]) -> URL {
        var _URLComponents = URLComponents(url: baseURL, resolvingAgainstBaseURL: true)!

        if let lastCharacter = _URLComponents.path.last {
            if lastCharacter != Character("/") {
                _URLComponents.path.append("/")
            }
        } else {
            _URLComponents.path.append("/")
        }

        _URLComponents.path.appendPath(path)

        let resultQueryItems = queryItems + additionalURLQueryItems

        if !resultQueryItems.isEmpty {
            _URLComponents.queryItems = resultQueryItems
        }

        return _URLComponents.url!
    }

    /// Concrete implementation of `NetworkRequest.==(_,_)`
    ///
    /// - Parameter otherRequest: The request to compare to
    /// - Returns: If `self` and `otherRequest` are equal
    open func isEqual(otherRequest: NetworkRequest) -> Bool {
        return self.HTTPMethod == otherRequest.HTTPMethod &&
            self.HTTPHeaders == otherRequest.HTTPHeaders &&
            self.path == otherRequest.path &&
            self.queryItems == otherRequest.queryItems
    }

    /// This method checks for __partial__ equality. Since we can't compare two `InputStreams`,
    ///  we'll ignore it and have a higher-level class decide for us. You shouldn't be using this class as-is anyways.
    ///
    /// - Parameters:
    ///   - lhs: A network request
    ///   - rhs: Another network request
    /// - Returns: If the two requests are equal
    public static func == (lhs: NetworkRequest, rhs: NetworkRequest) -> Bool {
        return lhs.isEqual(otherRequest: rhs)
    }

    /// Internal function that updates the `Content-Type` header based on the specific `contentType` attribute,
    /// and if present, `encoding` attribute
    internal func updateContentType() {
        let contentTypeHeader: String?

        defer {
            HTTPHeaders[.contentType] = contentTypeHeader
        }

        guard let contentType = contentType else {
            contentTypeHeader = nil

            return
        }

        contentTypeHeader = NetworkRequest.contentType(for: contentType, encoding: encoding)
    }

    /// Internal method that returns the appropriate value for the `Content-Type`
    /// header based on a given content type (MIME type) and an encoding
    ///
    /// - Parameters:
    ///   - contentType: A content type (i.e. a MIME type)
    ///   - encoding: The associated encoding
    /// - Returns: A concatenated value, to be used for the `Content-Type` header
    internal static func contentType(for contentType: String, encoding: String.Encoding?) -> String {
        let encodingString: String?

        if let encoding = encoding {
            let cfEncoding = CFStringConvertNSStringEncodingToEncoding(encoding.rawValue)

            encodingString = CFStringConvertEncodingToIANACharSetName(cfEncoding) as String?
        } else {
            encodingString = nil
        }

        if let encodingString = encodingString {
            let charsetEncodingString = "charset=" + encodingString

            let contentTypeContents = [contentType, charsetEncodingString]

            return contentTypeContents.joined(separator: "; ")
        }

        return contentType
    }

    /// Gives the `NetworkRequest` an opportunity to perform some cleanup after the actual `URLRequest` was executed.
    ///
    /// - Important: Call `super`'s implementation
    ///
    /// - Warning: After calling this method, this instance of `NetworkRequest` is considered as dirty and invalid
    open func cleanup() {

    }

    public var customMirror: Mirror {
        let constructedPath: String = {
            let url = constructURL(baseURL: URL(string: "https://foo.bar/")!, additionalURLQueryItems: [])

            let components = URLComponents(url: url, resolvingAgainstBaseURL: false)!

            let urlString = components.string!

            return String(urlString[components.rangeOfPath!.lowerBound...])
        }()

        let children: [Mirror.Child] = [(label: "HTTPMethod", value: HTTPMethod),
                                        (label: "path", value: path),
                                        (label: "constructedPath", value: constructedPath),
                                        (label: "authorizationRequirement", value: authorizationRequirement),
                                        (label: "HTTPHeaders", value: HTTPHeaders),
                                        (label: "queryItems", value: queryItems)]

        return Mirror(self,
                      children: children,
                      displayStyle: .class)
    }
}

public extension String {
    // swiftlint:enable missing_docs

    /// Characters to strip, currently `/`
    private static let charactersToStrip = CharacterSet(charactersIn: "/")

    /// Helper method that appends a path component à la NSString
    ///
    /// - Parameter other: The path to append
    mutating func appendPath(_ other: String) {
        var sanitizedString = other

        if !isEmpty {
            if sanitizedString.first == "/" {
                sanitizedString = String(sanitizedString.dropFirst())
            }
        }

        if sanitizedString.last == "/" {
            sanitizedString = String(sanitizedString.dropLast())
        }

        guard !isEmpty else {
            append(contentsOf: sanitizedString)

            return
        }

        if last == "/" {
            append(sanitizedString)

            return
        }

        append("/" + sanitizedString)
    }

    /// Helper method that appends a path component à la NSString and returns a new String
    ///
    /// - Parameter aString: The path to append
    /// - Returns: The updated string
    func appendingPath<T>(_ aString: T) -> String where T: StringProtocol {
        var sanitizedString = aString

        if !isEmpty {
            if sanitizedString.first == "/" {
                sanitizedString = String(sanitizedString.dropFirst()) as! T
            }
        }

        if sanitizedString.last == "/" {
            sanitizedString = String(sanitizedString.dropLast()) as! T
        }

        guard !isEmpty else {
            return appending(sanitizedString)
        }

        if last == "/" {
            return appending(sanitizedString)
        }

        return appending("/" + sanitizedString)
    }
}

public func URLQueryItemString(dictionary: [String: Any]) -> String {
    var components = URLComponents()
    print(components.url!)
    components.queryItems = dictionary.map {
        URLQueryItem(name: $0, value: String(describing: $1))
    }
    return (components.url?.absoluteString)!
}
